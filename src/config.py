"""
Глобальные настройки приложения.

- численные "предохранители" (EPS_*),
- параметры аппроксимации и ограничения сложности (RICCI_*),
- статистические пороги (JUMP_*, NULL_*),
- настройки визуализации и ограничения памяти UI.

Это НЕ константы предметной области.
Это дефолты, обеспечивающие разумный баланс устойчивости и скорости
для графов среднего размера (~10^2–10^4 вершин).
их МОЖНО менять, если ОЧЕНЬ, правда уверен в том, что делаешь. иначе -- уоучше не трогать.
просьба здесь ОБРАТИТЬ ВНИМАНИЕ НА КОММЕНТАРИИ, ОНИ ВАЖНЫ.

"""

from __future__ import annotations
from dataclasses import dataclass


# =========================
# Численная устойчивость
# =========================

# Защита для операций вида dist = 1 / w.
# Предотвращает деление на ноль и "взрыв" расстояний.
#
# Как подбирать:
#   должно быть на 3–6 порядков меньше минимального
#   осмысленного положительного веса в данных.
EPS_W: float = 1e-12


# Защита для log(p) в энтропиях и дивергенциях.
# Предотвращает log(0) и появление -inf.
#
# Как подбирать:
#   достаточно мало, чтобы не искажать хвост распределения,
#   но не настолько мало, чтобы возникал underflow.
#   Типичный безопасный диапазон: 1e-15 ... 1e-30.
EPS_LOG: float = 1e-20


# =========================
# Параметры кривизны Риччи
# =========================

# Масштабирование массы в транспортной задаче.
# Улучшает численную устойчивость / дискретизацию.
#
# Больше → выше точность, но выше стоимость вычислений.
# Практический диапазон: 1e4 – 1e6.
#в любом случае, риччи считается, толкьо если попросить, так что...
# в случае чего можно просто подождать.
RICCI_MASS_SCALE: int = 120_000


# Максимальный размер опоры (число соседей),
# участвующих в локальной транспортной задаче.
#
# Меньше → грубая аппроксимация.
# Больше → рост сложности (вплоть до кубического по степени вершины).
# Рекомендуемый диапазон: 20 – 200.
RICCI_MAX_SUPPORT: int = 60


# Порог отсечения по расстоянию/стоимости при локальном транспорте.
#
# Меньше → обрезаются дальние вклады.
# Больше → растёт размер опоры и время вычисления.
#
# Интерпретируется в единицах используемой метрики!!!
RICCI_CUTOFF: float = 8.0


# Число рёбер, используемых в preview / быстром режиме.
#
# Меньше → быстрее, но выше шум.
# Больше → медленнее, но стабильнее оценка.
# Для интерактивного режима обычно 50–200.
RICCI_SAMPLE_EDGES: int = 80


# =========================
# Детекция фазовых "скачков"
# =========================

# Уровень значимости (квантиль) для порога в нулевой модели.
#
# Меньше → более строгая детекция.
# Стандартные значения: 0.05, 0.01, 0.001. именно это значение диктует, что мы считаем "переходом"
JUMP_ALPHA: float = 0.01


# Эвристический порог относительного изменения
# (используется в быстром режиме без нулевой модели).
#
# Интерпретируется как доля изменения метрики.
# Должен соответствовать "заметному" эффекту в ваших данных.
JUMP_FRACTION_FALLBACK: float = 0.35


# Число итераций нулевой модели по умолчанию.
#
# Точность p-value ~ 1 / (N_iter + 1).
# 20–50 — интерактив.
# 200+ — финальный расчёт.
NULL_N_ITER_DEFAULT: int = 25


@dataclass(frozen=True)
class Settings:
    """
    Настройки уровня приложения 
    Влияют на:
    - визуализацию,
    - воспроизводимость,
    - обработку весов,
    - ограничения аппроксимации,
    - защиту памяти UI.
    """

    PLOT_HEIGHT: int = 800
    PLOT_TEMPLATE: str = "plotly_dark"
    COLOR_PRIMARY: str = "#ff4b4b"
    ANIMATION_DURATION_MS: int = 150


    # =========================
    # Воспроизводимость
    # =========================

    # Seed по умолчанию для случайных процедур.
    DEFAULT_SEED: int = 42
    # потому что 42.

    # =========================
    # обработка весов
    # =========================

    # Возможные значения:
    #
    # "drop_nonpositive":
    #     удалить рёбра с w <= 0.
    #     Корректно при использовании dist = 1 / w (требуется w > 0).
    #
    # "abs":
    #     заменить w <- |w|.
    #     Подходит для корреляций, но теряется знак.
    #
    # "clip":
    #     заменить w <- max(w, eps).
    #     Сохраняет рёбра, но может создать огромные расстояния.
    #
    # "shift":
    #     заменить w <- w + shift, затем max(w, eps).
    #     Полезно, если веса центрированы вокруг нуля.
    WEIGHT_POLICY: str = "drop_nonpositive"

    # Минимальный порог в режимах clip/shift.
    WEIGHT_EPS: float = 1e-9

    # Сдвиг в режиме shift.
    WEIGHT_SHIFT: float = 0.0


    # =========================
    # Параметры аппроксимации
    # =========================

    RICCI_CUTOFF: float = RICCI_CUTOFF
    RICCI_MAX_SUPPORT: int = RICCI_MAX_SUPPORT
    RICCI_SAMPLE_EDGES: int = RICCI_SAMPLE_EDGES

    # Параметр аппроксимации глобальной эффективности.
    # Больше → точнее, но медленнее.
    APPROX_EFFICIENCY_K: int = 32


    # =========================
    # Ограничения памяти UI
    # =========================

    # Максимальное число графов в памяти.
    # Защита от разрастания session state.
    MAX_GRAPHS_IN_MEMORY: int = 8

    # Максимальное число экспериментов в памяти.
    MAX_EXPS_IN_MEMORY: int = 40


    # =========================
    # Параметры динамики энергии
    # =========================

    # Коэффициент демпфирования (0 < damping ≤ 1).
    # Ближе к 1 → медленное затухание.
    DEFAULT_DAMPING: float = 0.98

    # Амплитуда инъекции энергии.
    DEFAULT_INJECTION: float = 1.0

    # Коэффициент утечки за шаг.
    # Больше → быстрее рассеивается энергия.
    DEFAULT_LEAK: float = 0.005


settings = Settings()
